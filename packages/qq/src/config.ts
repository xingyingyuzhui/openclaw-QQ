import { z } from "zod";

export const QQConfigSchema = z.object({
  wsUrl: z.string().url().describe("The WebSocket URL of the OneBot v11 server (e.g. ws://localhost:3001)"),
  accessToken: z.string().optional().describe("The access token for the OneBot server"),
  ownerUserId: z.string().optional().default("").describe("Optional QQ user ID that should map to main agent."),
  admins: z.array(z.number()).optional().describe("List of admin QQ numbers"),
  requireMention: z.boolean().optional().default(true).describe("Require @mention or reply to bot in group chats"),
  systemPrompt: z.string().optional().describe("Custom system prompt to inject into the context"),
  enableDeduplication: z.boolean().optional().default(true).describe("Enable message deduplication to prevent double replies"),
  enableErrorNotify: z.boolean().optional().default(true).describe("Notify admins or users when errors occur"),
  autoApproveRequests: z.boolean().optional().default(false).describe("Automatically approve friend/group add requests"),
  maxMessageLength: z.number().optional().default(4000).describe("Maximum length of a single message before splitting"),
  formatMarkdown: z.boolean().optional().default(false).describe("Format markdown to plain text for better readability"),
  antiRiskMode: z.boolean().optional().default(false).describe("Enable anti-risk processing (e.g. modify URLs)"),
  allowedGroups: z.array(z.number()).optional().describe("Whitelist of group IDs allowed to interact with"),
  blockedUsers: z.array(z.number()).optional().describe("Blacklist of user IDs to ignore"),
  historyLimit: z.number().optional().default(5).describe("Number of history messages to include in context"),
  keywordTriggers: z.array(z.string()).optional().describe("List of keywords that trigger the bot (without @)"),
  enableTTS: z.boolean().optional().default(false).describe("Experimental: Convert AI text replies to voice (TTS)"),
  enableGuilds: z.boolean().optional().default(true).describe("Enable QQ Guild (Channel) support"),
  rateLimitMs: z.number().optional().default(1000).describe("Delay in ms between sent messages to avoid risk"),
  sendQueueBaseDelayMs: z.number().optional().default(1000).describe("Base delay in ms between outbound send tasks in global queue"),
  sendQueueJitterMs: z.number().optional().default(400).describe("Random jitter in ms added to outbound queue delay"),
  sendQueueMaxRetries: z.number().optional().default(3).describe("Maximum retry attempts for transient outbound send failures"),
  sendRetryMinDelayMs: z.number().optional().default(500).describe("Minimum retry backoff delay in ms"),
  sendRetryMaxDelayMs: z.number().optional().default(8000).describe("Maximum retry backoff delay in ms"),
  sendRetryJitterRatio: z.number().optional().default(0.15).describe("Retry jitter ratio (0~1), e.g. 0.15 for Â±15% jitter"),
  sendWaitForReconnectMs: z.number().optional().default(5000).describe("Wait this long for reconnect before counting a send attempt as failed"),
  strictRouteIsolation: z.boolean().optional().default(true).describe("Bind sessions and reply routes to exact inbound source route"),
  enableConversationPolicyHook: z.boolean().optional().default(false).describe("Reserved hook flag for future per-conversation permission gating"),
  mediaProxyEnabled: z.boolean().optional().default(false).describe("Enable media proxy URL rewrite for outbound media"),
  publicBaseUrl: z.string().optional().default("").describe("Public base URL reachable by NapCat, e.g. http://192.168.1.10:18789"),
  mediaProxyBaseUrl: z.string().optional().default("").describe("Alias of publicBaseUrl (compat): media proxy base URL reachable by NapCat"),
  mediaProxyToken: z.string().optional().default("").describe("Optional token appended to media proxy URL"),
  mediaProxyPath: z.string().optional().default("/qq/media").describe("Proxy path for media URL rewrite"),
  mediaProxyListenHost: z.string().optional().default("0.0.0.0").describe("Media relay listen host"),
  mediaProxyListenPort: z.number().optional().default(18890).describe("Media relay listen port"),
  mediaProxyTtlSec: z.number().optional().default(300).describe("Signed media relay URL TTL in seconds"),
  voiceBasePath: z.string().optional().default("").describe("Base directory for relative voice/audio file paths"),
  mediaPathAllowlist: z.array(z.string()).optional().default([]).describe("Additional absolute directories allowed for MEDIA: local path resolution"),
  mediaHttpFallbackToBase64: z.boolean().optional().default(true).describe("When HTTP media send fails, allow fallback to base64 payload"),
  inboundMediaResolvePrefer: z.enum(["napcat-first", "direct-first"]).optional().default("napcat-first").describe("Inbound media resolution strategy preference"),
  inboundMediaHttpTimeoutMs: z.number().optional().default(8000).describe("Timeout in ms for inbound HTTP media materialization"),
  inboundMediaHttpRetries: z.number().optional().default(2).describe("Retry attempts for inbound HTTP media materialization"),
  inboundMediaUseStream: z.boolean().optional().default(true).describe("Enable stream-based inbound media resolve attempts before legacy download fallback"),
  inboundMediaFallbackGetMsg: z.boolean().optional().default(true).describe("When inbound media refs are unresolved, use get_msg to retry unresolved refs only"),
  inboundMediaMaxPerMessage: z.number().optional().default(8).describe("Maximum media refs to process per inbound message to avoid overload"),
  aggregateWindowMs: z.number().optional().default(900).describe("Aggregate rapid inbound messages on same route within this window before dispatch"),
  replyRunTimeoutMs: z.number().optional().default(600000).describe("Timeout in ms for one inbound dispatch run before fallback notification"),
  taskMaxRuntimeMs: z.number().optional().default(120000).describe("Hard max runtime in ms for heavy child task units"),
  taskMaxRetries: z.number().optional().default(1).describe("Hard max retries for heavy child task units"),
  taskMaxConcurrency: z.number().optional().default(1).describe("Hard max concurrent child task units per route"),
  taskIdempotencyEnabled: z.boolean().optional().default(true).describe("Enable deterministic idempotency guard for child task units"),
  replyAbortOnTimeout: z.boolean().optional().default(true).describe("Abort in-flight reply run when replyRunTimeoutMs is reached"),
  outboundFallbackOnDrop: z.boolean().optional().default(true).describe("When a run produced output but all outbound attempts were dropped, send one short fallback message"),
  outboundFallbackCooldownMs: z.number().optional().default(30000).describe("Cooldown in ms for fallback message per route"),
  outboundAbortPatternStrict: z.boolean().optional().default(true).describe("Use strict abort pattern suppression for outbound text"),
  adaptiveTimeoutDegradeWindowMs: z.number().optional().default(60000).describe("When recent timeout detected, temporarily degrade adaptive interrupt behavior to queue-latest"),
  routePreemptOldRun: z.boolean().optional().default(true).describe("Preempt old in-flight run on the same route when a new inbound arrives"),
  interruptPolicy: z.enum(["preempt", "queue-latest", "adaptive"]).optional().default("adaptive").describe("Interrupt policy for same-route concurrent inbound dispatch"),
  mediaInterruptPolicy: z.enum(["queue-latest", "adaptive-preempt"]).optional().default("queue-latest").describe("Interrupt policy override when current inbound contains media"),
  historyIncludeMedia: z.boolean().optional().default(false).describe("Whether to include inbound media hints in chat history/system context by default"),
  historyMediaMaxItems: z.number().optional().default(1).describe("Maximum number of inbound media hints to inject into context"),
  streamTransportEnabled: z.boolean().optional().default(true).describe("Enable stream transport adapter for media when NapCat supports it"),
  streamTransportPrefer: z.enum(["upload-first", "legacy-first"]).optional().default("upload-first").describe("Prefer stream upload candidates before legacy media candidates"),
  interruptCoalesceEnabled: z.boolean().optional().default(true).describe("When a new inbound arrives during an in-flight run, coalesce for a short quiet window before starting latest run"),
  interruptWindowMs: z.number().optional().default(0).describe("Interrupt coalesce window in ms; 0 means follow aggregate window"),
  interruptCoalesceMs: z.number().optional().default(900).describe("Quiet window in ms for interrupt coalescing after preempt"),
  proactiveDmEnabled: z.boolean().optional().default(false).describe("Enable proactive DM nudges for specific routes"),
  proactiveDmRoute: z.string().optional().default("user:2151539153").describe("Target route for proactive DM nudges"),
  proactiveDmMinSilenceMs: z.number().optional().default(90 * 60 * 1000).describe("Minimum silence before sending proactive DM"),
  proactiveDmMinIntervalMs: z.number().optional().default(2 * 60 * 60 * 1000).describe("Minimum interval between proactive DM sends"),
  proactiveUseCoreScheduler: z.boolean().optional().default(true).describe("Use gateway core proactive scheduler instead of plugin-local timer"),
  proactiveSchedulerTickSec: z.number().optional().default(60).describe("Proactive scheduler cadence in seconds"),
  proactiveMirrorRequired: z.boolean().optional().default(true).describe("Require mirror session metadata for proactive sends"),
  proactiveDmTickMs: z.number().optional().default(60_000).describe("Proactive scheduler tick interval in ms"),
  proactiveDmLogVerbose: z.boolean().optional().default(false).describe("Enable verbose proactive tick/skip/state logs"),
  loggingTraceEnabled: z.boolean().optional().default(true).describe("Write structured route-level trace logs to qq_sessions/<route>/logs/trace-*.ndjson"),
  loggingVerboseErrors: z.boolean().optional().default(false).describe("Enable verbose diagnostics logger internal error output"),
  sessionKeyMode: z.enum(["agent-main"]).optional().default("agent-main").describe("Session key strategy mode; only agent-main is supported"),
});

export type QQConfig = z.infer<typeof QQConfigSchema>;
